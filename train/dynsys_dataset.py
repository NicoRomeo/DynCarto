"""Dataset class for dynamical system data

Defines a DynsysDataset class inherited from PyTorch's Dataset class to handle sampling from sets of dynamical system trajectories.

"""

import numpy as np
import h5py
import torch
from torch.utils.data import Dataset
from tqdm import tqdm

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

class DynsysDataset(Dataset):
    """A Dataset class for dynamical system data.

    Parameters:
    data_h5: input filename
    transform=None: transformation applied to inputs (pytorch format)
    target_transform=None:  transformation applied to target (pytorch format)
    stride=1 (int): time downsampling factor. stride=1 means no downsampling.
    isjulia=True: if True, input data are assumed to be generated by julia (1-indexed, column-major).
                if False, assumed to be generated by Python (0-indexed, row-major)
    """
    
    def __init__(self, data_h5, transform=None, target_transform=None, stride=1, isjulia=True):
        self.filename = data_h5 # filename
        with h5py.File(data_h5, 'r') as f:
            self.len = len(f.keys())
        self.file = h5py.File(data_h5, 'r')
        self.transform = transform
        self.target_transform = target_transform
        self.stride = stride
        self.isjulia = isjulia

    def __len__(self):
        return self.len

    def __getitem__(self, idx):
        if self.isjulia:
            dset = self.file[str(idx+1)]
            params = dset.attrs["params"]
            label = params[-1]
            system = torch.permute(torch.from_numpy(dset[:,::self.stride,:]).float().to(device), (2, 1, 0)
                    )
        else:
            dset = self.file[str(idx)]
            params = dset.attrs["params"]
            label = params[-1]
            system = np.float(dset[:,::self.stride,:])
        if self.transform:
            system = self.transform(system)
        if self.target_transform:
            label = self.target_transform(label)
        return system, label
    
class DynsysDatasetGPU(Dataset):
    """A Dataset class for dynamical data optimized for the GPU - it also works for CPU. 
    Unlike the CPU class, all data are preloaded onto the GPU memory to enable faster training.
     
    Parameters:
    data_h5: input filename
    transform=None: transformation applied to inputs (pytorch format)
    target_transform=None:  transformation applied to target (pytorch format)
    stride=1 (int): time downsampling factor. stride=1 means no downsampling.
    isjulia=True: if True, input data are assumed to be generated by julia (1-indexed, column-major).
                if False, assumed to be generated by Python (0-indexed, row-major)
    """
    def __init__(self, data_h5, transform=None, target_transform=None, stride=1, isjulia=True):
        self.filename = data_h5 # filename
        with h5py.File(data_h5, 'r') as f:
            self.len = len(f.keys())
        self.stride = stride
        self.file = h5py.File(data_h5, 'r')
        self.isjulia = isjulia
        # load the entire data onto the GPU
        if isjulia:
            dset0 = self.file["1"]
            dset_shape = dset0[:,::self.stride,:].shape
            self.data = torch.zeros((self.len, dset_shape[2], dset_shape[1], dset_shape[0]), device=device)
            for idx in tqdm(range(1, self.len+1)):
                dset = self.file[str(idx)]
                self.data[idx-1,:,:,:] = torch.permute(
                    torch.from_numpy(dset[:,::self.stride,:]).float().to(device), (2, 1, 0)
                )
        else:
            dset0 = self.file["0"]
            dset_shape = dset0[:,::self.stride,:].shape
            self.data = torch.zeros((self.len, dset_shape[0], dset_shape[1], dset_shape[2]), device=device)
            for idx in tqdm(range(self.len)):
                dset = self.file[str(idx)]
                self.data[idx,:,:,:] = torch.from_numpy(dset[:,::self.stride,:]).float().to(device)
        self.transform = transform
        self.target_transform = target_transform
        
    def __len__(self):
        return self.len

    def __getitem__(self, idx):
        """ required by the Dataset class. returns the data for system with index idx"""
        system = torch.squeeze(self.data[idx,:,:,:])
        if self.transform:
            system = self.transform(system)
        return system, idx
